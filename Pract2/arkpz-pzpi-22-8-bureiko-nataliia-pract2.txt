Міністерство освіти і науки України
Харківський національний університет радіоелектроніки





Кафедра програмної інженерії




ЗВІТ
 з практичної роботи №2
з дисципліни «Аналіз та рефакторинг коду»
на тему «Методи рефакторингу коду програмного забезпечення»





Виконала:                                                                      Перевірив:
студ. гр. ПЗПІ-22-8                                                       ст. викл. каф. ПІ 
Бурейко Н. М.                                                                Сокорчук І. П.





Харків 2024
     2 МЕТОДИ РЕФАКТОРИНГУ КОДУ ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ
     
     
2.1  Мета роботи
     Ознайомитись з основними методами рефакторингу коду на основі реальних прикладів з власних програмних продуктів. Навчитись ідентифікувати проблеми в коді та використовувати відповідні методи рефакторингу для покращення якості.
     
2.2  Хід роботи
     Виберемо три методи рефакторингу для детального розгляду. У минулих проєктах знайдемо код, що потребує рефакторингу обраними методами, опишемо причину рефакторингу, відредагуємо код та пояснемо покращення.
     Перший метод називається Remove Control Flag. Суть полягає в заміні змінної, яка діє як керуючий прапорець для серії логічних виразів, на break або return. 
     Розглянемо приклад коду:
  1         public static string SearchNextSuspiciousEvent()
  2         {
  3             String found = "";
  4
  5             foreach (var ev in Events)
  6             {
  7                 string name = ev.Name.ToLower();
  8
  9                 if (SpecialGroup.Any(keyword => name.Contains(keyword.ToLower())))
 10                 {
 11                     if (ev.Date.TimeOfDay > TimeSpan.FromHours(21))
 12                     {
 13                         found = $"Найближча підозріла подія (пізно ввечері): {ev.Name} ({ev.Date.DayOfWeek})";
 14                     }
 15
 16                     if (ev.Date.TimeOfDay < TimeSpan.FromHours(8))
 17                     {
 18                         found = $"Найближча підозріла подія (рано вранці): {ev.Name} ({ev.Date.DayOfWeek})";
 19                     }
 20
 21                     if (!string.IsNullOrEmpty(found))
 22                     {
 23                         return found;
 24                     }
 25                 }
 26             }
 27
 28             return "У Вас немає підозрілих подій";
 29         }
     У коді використовується змінна-флаг (found), що виконує роль контролю потоку виконання. Це призводить до деякої складності в розумінні коду і збільшує ймовірність помилок, оскільки зміна значення флага в середині циклу призводить до багатьох умовних перевірок, і це утруднює підтримку коду. Отже, маємо такі проблеми: складність розуміння, ризик помилок та ускладнене тестування.
     Проведемо рефакторинг коду за допомогою Remove Control Flag:
  1         public static string SearchNextSuspiciousEvent()
  2         {
  3             foreach (var ev in Events)
  4             {
  5                 string name = ev.Name.ToLower();
  6
  7                 if (SpecialGroup.Any(keyword => name.Contains(keyword.ToLower())))
  8                 {
  9                     if (ev.Date.TimeOfDay > TimeSpan.FromHours(21))
 10                     {
 11                         return $"Найближча підозріла подія (пізно ввечері): {ev.Name} ({ev.Date.DayOfWeek})";
 12                     }
 13
 14                     if (ev.Date.TimeOfDay < TimeSpan.FromHours(8))
 15                     {
 16                         return $"Найближча підозріла подія (рано вранці): {ev.Name} ({ev.Date.DayOfWeek})";
 17                     }
 18                 }
 19             }
 20
 21             return "У Вас немає підозрілих подій";
 22         }

     Тепер код не використовує флагів, що робить логіку більш зрозумілою. Одразу видно, що метод повертає результат при знаходженні події, яка відповідає умовам, і не потрібно використовувати додаткові перевірки. Логіка методу стала лінійною, без необхідності вести додаткові перевірки флагів. Код став більш компактним і менш заплутаним. 
     Тепер маємо менше дублювання: раніше ми мали кілька блоків коду, що перевіряють умови, а тепер просто використовуємо return для виходу з методу при знаходженні підозрілих подій. Також тестування стало легшим, оскільки стало менше умов і більше чітких результатів.
     Розглянемо наступний метод, а саме Encapsulate Field. Суть методу полягає в зміні публічного поля на приватне і наданні аксесорів. 
     Розглянемо приклад коду:
  1     internal class Event
  2     {
  3         string name;
  4         DateTime date;
  5         TimeSpan duration;
  6         string location;
  7
  8         public Event(string name)
  9         {
 10             Name = name;
 11         }

     Публічні поля порушують принцип інкапсуляції. Використовуючи публічне поле, ми дозволяємо зовнішнім об’єктам напряму змінювати значення, що ускладнює контроль змін і послаблює модульність коду. Без інкапсуляції об’єкти можуть модифікувати або отримувати доступ до даних без відома об'єкта, що володіє цими даними. 
     Коли до поля мають прямий доступ різні частини програми, важко відстежити, хто і коли його змінює. Це ускладнює процес налагодження, тестування та внесення змін. Якщо змінюється тип поля або логіка його обробки, всі зовнішні залежності потрібно коригувати, що ускладнює підтримку.
     Якщо в майбутньому з'явиться необхідність додати логіку валідації або додаткову обробку даних перед їх використанням, це буде важко зробити без геттерів і сеттерів, наприклад, якщо необхідно обмежити значення поля або відстежити зміни, доведеться переробляти інтерфейс доступу до даних.
     Проведемо рефакторинг методом Encapsulate Field, аби уникнути перерахованих вище проблем:
  1     internal class Event
  2     {
  3         string name;
  4         DateTime date;
  5         TimeSpan duration;
  6         string location;
  7
  8         public Event(string name)
  9         {
 10             Name = name;
 11         }
 12
 13         public Event(string name, DateTime date1, DateTime date2, string location)
 14         {
 15             Name = name;
 16             Date = date1;
 17             Duration = date2 - date1;
 18             Location = location;
 19         }
 20
 21         public string Name
 22         {
 23             get { return name; }
 24             set { name = value; }
 25         }
 26
 27         public DateTime Date
 28         {
 29             get
 30             {
 31                 return date;
 32             }
 33             set
 34             {
 35                 date = new DateTime(value.Year, value.Month, value.Day, value.Hour, value.Minute, 0);
 36             }
 37         }
 38
 39         public TimeSpan Duration
 40         {
 41             get
 42             {
 43                 return duration;
 44             }
 45             set
 46             {
 47                 duration = new TimeSpan(value.Days, value.Hours, value.Minutes, 0);
 48             }
 49         }
 50
 51         public string Location
 52         {
 53             get { return location; }
 54             set { location = value; }
 55         }
 56     }

     Код тепер краще читається, оскільки всі поля доступні тільки через геттери і сеттери. Інкапсуляція робить інтерфейс класу більш зрозумілим і керованим. Внесення змін у геттери і сеттери тепер може оброблятись в одному місці, що спрощує підтримку коду. Якщо потрібно буде змінити логіку зберігання або обробки даних, це можна буде зробити у геттерах/сеттерах. Також інкапсуляція покращує модульність класу, дозволяючи вільно змінювати приватні дані без ризику неконтрольованих зовнішніх змін.
     Розглянемо останній метод рефакторингу під назвою Replace Nested Conditional with Guard Clauses. Суть: коли метод має умовну поведінку, яка не дає чіткого уявлення про звичайний шлях виконання, треба використовувати захисні вирази (guard clauses) для всіх особливих випадків, тобто або використовувати команду return, або викидувати виключення.
     Розглянемо приклад коду:
  1 public static string ValidateMovingEvents(Event currentEvent, DateTime newDate, bool selectDate)
  2 {
  3     string validationResult = null;
  4
  5     if (currentEvent == null)
  6     {
  7         validationResult = "Ви не обрали назву справи!";
  8     }
  9     else
 10     {
 11         if (!selectDate)
 12         {
 13             validationResult = "Ви не ввели дату та час початку!";
 14         }
 15         else
 16         {
 17             DateTime oldDate = currentEvent.Date;
 18             currentEvent.Date = newDate;
 19
 20             string overlays = ValidateOverlaysToMove(currentEvent);
 21             if (overlays != null)
 22             {
 23                 validationResult = overlays;
 24                 currentEvent.Date = oldDate;
 25             }
 26         }
 27     }
 28
 29     return validationResult;
 30 }

     Вкладені умови обтяжують сприйняття основної логіки методу і роблять код менш інтуїтивно зрозумілим. Для кожного випадку використовується ланцюг умов, що знижує ефективність аналізу коду.
     При необхідності додавання нових умов або змін у логіці обробки валідації коду, будь-які зміни можуть ускладнити підтримку. Вкладені умови роблять код менш гнучким до змін. 
     Код є складним для масштабування та модульного тестування.
     Проведемо рефакторинг методом Replace Nested Conditional with Guard Clauses, аби уникнути перерахованих вище проблем:
  1 public static string ValidateMovingEvents(Event currentEvent, DateTime newDate, bool selectDate)
  2 {
  3     if (currentEvent == null)
  4     {
  5         return "Ви не обрали назву справи!";
  6     }
  7
  8     if (!selectDate)
  9     {
 10         return "Ви не ввели дату та час початку!";
 11     }
 12
 13     DateTime oldDate = currentEvent.Date;
 14     currentEvent.Date = newDate;
 15
 16     string overlays = ValidateOverlaysToMove(currentEvent);
 17     if (overlays != null)
 18     {
 19         currentEvent.Date = oldDate;
 20         return overlays;
 21     }
 22
 23     return null;
 24 }

     Тепер кожен «незвичайний» випадок перевіряється і повертається одразу. Це дає можливість уникнути глибоких вкладених умов, а потік виконання стає чітким і простим для розуміння. 
     Підтримуваність коду підвищилась, оскільки зміни можна внести в кожен окремий блок перевірки без необхідності переписувати чи змінювати решту методу. 
     Перевірка кожної умови одразу дозволяє позбутися дублювання кодових частин і забезпечити чітке визначення результату.
     Головний потік виконання методу є очевидним, що спрощує розуміння та аналіз коду. Якщо в майбутньому потрібно буде додати нову перевірку або змінити поточну, це зробити набагато простіше.
     
     Висновки
     Під час виконання практичної роботи були розглянуті основні методи рефакторингу коду. Завдяки аналізу реальних прикладів з власних проєктів, ми навчилися виявляти проблеми в коді та ефективно застосовувати методи рефакторингу, такі як Remove Control Flag, Encapsulate Field і Replace Nested Conditional with Guard Clauses. Це дозволило зробити код більш зрозумілим, компактним, зручним для тестування та підтримки, а також знизити ймовірність виникнення помилок у майбутньому.
     Розроблено презентацію до практичної роботи (слайди презентації розташовані в додатку А). Відеозапис захисту презентації можна знайти за наступним посиланням: https://youtu.be/UXWrXo-Qwd4.
     
     
     
     
     
     
     
     
     
     
     
     
     
     ДОДАТОК А
     Презентація



Рисунок А.1   Титульний слайд


Рисунок А.2   Зміст

Рисунок А.3   Ознайомлення з поняттям рефакторингу


Рисунок А.4   Розгляд першого методу рефакторингу (перша частина)


Рисунок А.5   Розгляд першого методу рефакторингу (друга частина)


Рисунок А.6   Розгляд другого методу рефакторингу (перша частина)



Рисунок А.7   Розгляд другого методу рефакторингу (друга частина)


Рисунок А.8   Розгляд третього методу рефакторингу (перша частина)

	
Рисунок А.9   Розгляд третього методу рефакторингу (друга частина)


Рисунок А.10   Огляд інструментів для рефакторингу



Рисунок А.11   Висновки


Рисунок А.12   Джерела
	

Рисунок А.13   Подяка за увагу



